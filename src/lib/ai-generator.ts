import { AppConfig, Question } from '@/types';
import { toast } from '@/components/ui/use-toast';
import { v4 as uuidv4 } from 'uuid';
import OpenAI from 'openai';

// Store API key in a variable (in production, this should come from environment variables)
let openaiApiKey: string | null = null;

// Initialize OpenAI client
const createOpenAIClient = () => {
  if (!openaiApiKey) {
    throw new Error("OpenAI API key not set");
  }
  return new OpenAI({
    apiKey: openaiApiKey,
    dangerouslyAllowBrowser: true // Note: In production, API requests should be made from a backend
  });
};

export function setOpenAIApiKey(apiKey: string): void {
  openaiApiKey = apiKey;
  localStorage.setItem('openai_api_key', apiKey);
}

export function getOpenAIApiKey(): string | null {
  if (!openaiApiKey) {
    // Try to load from localStorage
    const storedKey = localStorage.getItem('openai_api_key');
    if (storedKey) {
      openaiApiKey = storedKey;
    }
  }
  return openaiApiKey;
}

export function clearOpenAIApiKey(): void {
  openaiApiKey = null;
  localStorage.removeItem('openai_api_key');
}

export async function generateQuestions(
  text: string,
  config: AppConfig
): Promise<Question[]> {
  // Check if API key is set
  if (!getOpenAIApiKey()) {
    toast({
      title: "API Key Required",
      description: "Please set your OpenAI API key in the settings before generating questions.",
      variant: "destructive",
    });
    return [];
  }
  
  // Check if text is too short (less than 50 characters per requested question)
  const minTextLength = config.numberOfQuestions * 50;
  if (text.length < minTextLength) {
    toast({
      title: "Insufficient content",
      description: `Your content is too short to generate ${config.numberOfQuestions} questions. Please provide more text.`,
      variant: "destructive",
    });
    return [];
  }
  
  try {
    const openai = createOpenAIClient();
    
    // Create system prompt based on configuration
    const systemPrompt = `You are an expert educator creating multiple-choice questions. 
Generate ${config.numberOfQuestions} ${config.difficultyLevel}-difficulty multiple-choice questions based on the provided text. 
Each question should have exactly 4 options with only one correct answer.
Format your response as a valid JSON array with this structure:
[
  {
    "text": "Question text goes here?",
    "options": ["Option A", "Option B", "Option C", "Option D"],
    "correctAnswer": 0 (index of correct option, 0-3)
  },
  ...more questions
]`;

    // Call OpenAI API
    const response = await openai.chat.completions.create({
      model: "gpt-4o", // Using GPT-4o for higher quality questions
      messages: [
        { role: "system", content: systemPrompt },
        { role: "user", content: `Generate multiple-choice questions from the following content:\n\n${text}` }
      ],
      temperature: 0.7,
      max_tokens: 2000,
      response_format: { type: "json_object" }
    });
    
    // Extract the generated content
    const content = response.choices[0]?.message?.content;
    if (!content) {
      throw new Error("No content received from OpenAI");
    }
    
    // Parse the JSON response
    try {
      const parsedResponse = JSON.parse(content);
      const questions = Array.isArray(parsedResponse.questions) ? parsedResponse.questions : 
                        Array.isArray(parsedResponse) ? parsedResponse : [];
      
      // Map to our Question format with unique IDs
      return questions.map((q: any) => ({
        id: uuidv4(),
        text: q.text,
        options: q.options || [],
        correctAnswer: q.correctAnswer
      }));
    } catch (parseError) {
      console.error("Failed to parse AI response:", parseError);
      throw new Error("Failed to parse the generated questions");
    }
  } catch (error) {
    console.error("Error calling OpenAI API:", error);
    throw error;
  }
}

// Keep the mock questions for fallback or testing
export const getMockQuestions = (count: number, difficulty: string): Question[] => {
  // Check if text is too short (less than 50 characters per requested question)
  const minTextLength = count * 50;
  if (text.length < minTextLength) {
    toast({
      title: "Insufficient content",
      description: `Your content is too short to generate ${count} questions. Please provide more text.`,
      variant: "destructive",
    });
    return [];
  }
  
  // Simulate API call delay
  await new Promise(resolve => setTimeout(resolve, 2000));
  
  // Generate mock questions based on config
  const questions: Question[] = [];
  
  // Mock questions - in a real app, these would be generated by an AI model
  const mockQuestions = [
    {
      text: "What is the primary purpose of the application described in the text?",
      options: [
        "To convert PDFs to text format",
        "To generate multiple-choice questions from content",
        "To edit and format PDF documents",
        "To translate text between languages"
      ],
      correctAnswer: 1
    },
    {
      text: "How many MCQs does the system aim to generate by default?",
      options: [
        "5-10 questions",
        "10-15 questions",
        "15-20 questions",
        "20-25 questions"
      ],
      correctAnswer: 2
    },
    {
      text: "What file formats can users input into the system?",
      options: [
        "PDF and Word documents",
        "Text and HTML",
        "PDF and plain text",
        "Images and text"
      ],
      correctAnswer: 2
    },
    {
      text: "What happens if the input text is too short?",
      options: [
        "The system will automatically expand the content",
        "The system will prompt the user to add more text",
        "Questions will be generated anyway",
        "The system will search for additional context online"
      ],
      correctAnswer: 1
    },
    {
      text: "What export format is mentioned in the core requirements?",
      options: [
        "PDF",
        "Word document",
        "Excel",
        "JSON"
      ],
      correctAnswer: 2
    },
    {
      text: "Which of these is suggested as a project improvement?",
      options: [
        "Voice recognition for input",
        "Custom question templates",
        "Multiple language support",
        "Image-based questions"
      ],
      correctAnswer: 2
    },
    {
      text: "How many answer options should each question have?",
      options: [
        "Two",
        "Three",
        "Four",
        "Five"
      ],
      correctAnswer: 2
    },
    {
      text: "Which of these features allows users to modify the AI's output?",
      options: [
        "Content verification",
        "Question review & edit",
        "Answer validation",
        "Difficulty calibration"
      ],
      correctAnswer: 1
    },
    {
      text: "What additional export formats are suggested beyond Excel?",
      options: [
        "PDF and Word",
        "HTML and XML",
        "CSV and JSON",
        "TXT and RTF"
      ],
      correctAnswer: 2
    },
    {
      text: "What UI characteristic is emphasized in the requirements?",
      options: [
        "Colorful and engaging",
        "Minimal with clear feedback",
        "Highly customizable",
        "Animated and interactive"
      ],
      correctAnswer: 1
    },
    {
      text: "What content check does the system perform before generating questions?",
      options: [
        "Plagiarism detection",
        "Grammar and spelling check",
        "Content sufficiency check",
        "Topic classification"
      ],
      correctAnswer: 2
    },
    {
      text: "What customization option would allow users to control question complexity?",
      options: [
        "Difficulty level control",
        "Topic selection",
        "Question type selector",
        "Language complexity filter"
      ],
      correctAnswer: 0
    },
    {
      text: "What technology is central to the question generation process?",
      options: [
        "Machine learning",
        "Natural language processing",
        "Artificial intelligence",
        "Neural networks"
      ],
      correctAnswer: 2
    },
    {
      text: "What is the main purpose of the Excel export functionality?",
      options: [
        "To analyze question statistics",
        "To organize questions and answers",
        "To print formatted quizzes",
        "To share with other applications"
      ],
      correctAnswer: 1
    },
    {
      text: "What user action initiates the question generation process?",
      options: [
        "Clicking the generate button after input",
        "Uploading a file or pasting text",
        "Setting configuration options",
        "Preview and confirmation"
      ],
      correctAnswer: 0
    },
    {
      text: "What should the interface prioritize according to the requirements?",
      options: [
        "Feature richness",
        "Simplicity and feedback",
        "Customization options",
        "Data visualization"
      ],
      correctAnswer: 1
    },
    {
      text: "What is expected to be included with each question?",
      options: [
        "Explanation of the answer",
        "Difficulty rating",
        "Source reference",
        "Four options and correct answer"
      ],
      correctAnswer: 3
    },
    {
      text: "What type of feedback should the user interface provide?",
      options: [
        "Detailed analytics",
        "Clear status updates",
        "Comparative metrics",
        "Historical usage data"
      ],
      correctAnswer: 1
    },
    {
      text: "What is a potential enhancement for the question generation capability?",
      options: [
        "Automated answer checking",
        "Customizable number of questions",
        "Academic reference linking",
        "Semantic similarity detection"
      ],
      correctAnswer: 1
    },
    {
      text: "What would make the application more accessible to global users?",
      options: [
        "Cloud synchronization",
        "Mobile responsiveness",
        "Multi-language support",
        "Alternative color schemes"
      ],
      correctAnswer: 2
    }
  ];
  
  // Adjust difficulty level by selecting questions
  let adjustedQuestions = [...mockQuestions];
  
  if (difficulty === 'easy') {
    // For easy, use more straightforward questions (first half)
    adjustedQuestions = mockQuestions.slice(0, mockQuestions.length / 2);
  } else if (difficulty === 'hard') {
    // For hard, use more complex questions (second half)
    adjustedQuestions = mockQuestions.slice(mockQuestions.length / 2);
  }
  
  // Select the requested number of questions
  for (let i = 0; i < count && i < adjustedQuestions.length; i++) {
    const q = adjustedQuestions[i];
    questions.push({
      id: uuidv4(),
      text: q.text,
      options: q.options,
      correctAnswer: q.correctAnswer
    });
  }
  
  return questions;
};
